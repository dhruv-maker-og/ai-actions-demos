name: "Demo 4: Documentation Auto-Updater (Project Bloom)"

# Triggers when code changes are pushed to src/ directory
on:
  push:
    branches:
      - main
      - develop
    paths:
      - 'src/**'
      - 'lib/**'
      - 'api/**'
  workflow_dispatch:  # Allow manual trigger

permissions:
  contents: write  # To commit documentation updates

jobs:
  update-documentation:
    runs-on: ubuntu-latest
    
    # Prevent infinite loops - don't run if only docs changed
    if: |
      !contains(github.event.head_commit.message, '[skip ci]') &&
      !contains(github.event.head_commit.message, 'docs:')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # fetch full history so HEAD^ exists
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          echo "‚úÖ Git configured for automated commits"

      - name: Analyze code changes
        id: analyze-changes
        run: |
          echo "üîç Analyzing code changes..."
          
          # Get list of changed files (handle first commit)
          if git rev-parse HEAD^ > /dev/null 2>&1; then
            git diff HEAD^ HEAD --name-only > changed_files.txt
          else
            # First commit - diff against empty tree
            git diff-tree --no-commit-id --name-only -r HEAD > changed_files.txt
          fi
          
          # Filter for source code files only
          grep -E '\.(py|js|ts|java|go|rs|cpp|c|h|rb)$' changed_files.txt > code_changes.txt || true
          
          CHANGE_COUNT=$(wc -l < code_changes.txt | tr -d ' ')
          echo "change_count=${CHANGE_COUNT}" >> $GITHUB_OUTPUT
          
          if [ "$CHANGE_COUNT" -eq "0" ]; then
            echo "‚ö†Ô∏è  No code changes detected"
            exit 0
          fi
          
          echo "‚úÖ Found ${CHANGE_COUNT} code file(s) changed"
          cat code_changes.txt
          
          # Get full diff (use xargs to safely pass filenames)
          if git rev-parse HEAD^ > /dev/null 2>&1; then
            cat code_changes.txt | xargs git diff HEAD^ HEAD -- > code_changes.diff
            ADDITIONS=$(git diff HEAD^ HEAD --numstat -- $(cat code_changes.txt) | awk '{sum+=$1} END {print sum+0}')
            DELETIONS=$(git diff HEAD^ HEAD --numstat -- $(cat code_changes.txt) | awk '{sum+=$2} END {print sum+0}')
          else
            cat code_changes.txt | xargs git show HEAD -- > code_changes.diff
            ADDITIONS=$(cat code_changes.txt | xargs git diff-tree --no-commit-id --numstat -r HEAD -- | awk '{sum+=$1} END {print sum+0}')
            DELETIONS=$(cat code_changes.txt | xargs git diff-tree --no-commit-id --numstat -r HEAD -- | awk '{sum+=$1} END {print sum+0}')
          fi
          
          echo "additions=${ADDITIONS}" >> $GITHUB_OUTPUT
          echo "deletions=${DELETIONS}" >> $GITHUB_OUTPUT
          
          echo "üìä Changes: +${ADDITIONS} -${DELETIONS}"

      - name: Identify relevant documentation
        id: find-docs
        if: steps.analyze-changes.outputs.change_count > 0
        run: |
          echo "üìö Finding relevant documentation files..."
          
          # Check if docs directory exists
          if [ ! -d "docs" ]; then
            mkdir -p docs
            echo "# Documentation" > docs/README.md
            echo "üìù Created docs directory"
          fi
          
          # List all documentation files
          find docs -type f -name "*.md" > doc_files.txt || echo "docs/README.md" > doc_files.txt
          
          DOC_COUNT=$(wc -l < doc_files.txt | tr -d ' ')
          echo "doc_count=${DOC_COUNT}" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Found ${DOC_COUNT} documentation file(s)"
          cat doc_files.txt

      - name: Load documentation update prompt
        id: load-prompt
        run: |
          # Read custom prompt template
          if [ -f ".github/prompts/docs-update-prompt.txt" ]; then
            cat .github/prompts/docs-update-prompt.txt > prompt_template.txt
            echo "‚úÖ Loaded custom documentation prompt"
          else
            # Default prompt
            cat << 'EOF' > prompt_template.txt
          You are a technical documentation specialist. Your task is to update documentation to reflect code changes.

          Guidelines:
          1. Maintain the existing documentation style and tone
          2. Be precise and accurate
          3. Update only sections affected by the code changes
          4. Preserve all other content unchanged
          5. Use clear, concise language
          6. Include code examples if relevant
          7. Update version numbers or dates if present
          EOF
            echo "‚ö†Ô∏è  Using default prompt (custom file not found)"
          fi

      - name: Read current documentation
        if: steps.analyze-changes.outputs.change_count > 0
        run: |
          echo "üìñ Reading current documentation..."
          
          # Combine all documentation into one context file
          echo "=== CURRENT DOCUMENTATION ===" > current_docs.txt
          echo "" >> current_docs.txt
          
          while IFS= read -r doc_file; do
            if [ -f "$doc_file" ]; then
              echo "--- File: $doc_file ---" >> current_docs.txt
              cat "$doc_file" >> current_docs.txt
              echo -e "\n" >> current_docs.txt
            fi
          done < doc_files.txt
          
          echo "‚úÖ Documentation context prepared"

      - name: Generate documentation updates with AI
        if: steps.analyze-changes.outputs.change_count > 0
        id: ai-update
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ü§ñ Generating documentation updates with AI..."
          
          # Read all context (use line-based truncation to avoid UTF-8 issues)
          PROMPT_TEMPLATE=$(cat prompt_template.txt)
          CURRENT_DOCS=$(cat current_docs.txt | head -n 200)  # Limit to prevent token overflow
          CODE_DIFF=$(cat code_changes.diff | head -n 150)     # Limit diff size
          CHANGED_FILES=$(cat code_changes.txt | tr '\n' ', ')
          
          # Build complete prompt
          FULL_PROMPT="${PROMPT_TEMPLATE}

          **Context:**
          - Repository: ${{ github.repository }}
          - Commit: ${{ github.sha }}
          - Author: ${{ github.event.head_commit.author.name }}
          - Commit Message: ${{ github.event.head_commit.message }}

          **Changed Files:**
          ${CHANGED_FILES}

          **Code Changes (diff):**
          \`\`\`diff
          ${CODE_DIFF}
          \`\`\`

          **Current Documentation:**
          ${CURRENT_DOCS}

          **Task:**
          Based on the code changes above, update the documentation appropriately. Return ONLY the updated documentation content for docs/README.md in Markdown format. Maintain the existing structure and style. Focus on documenting what changed, why it matters, and how to use any new features."
          
          # Create JSON request file safely using jq
          cat > request_base.json << 'EOFJ'
          {
            "model": "gpt-4o-mini",
            "messages": [
              {
                "role": "system",
                "content": "You are a technical documentation writer. Produce clear, accurate, and well-structured documentation."
              },
              {
                "role": "user",
                "content": ""
              }
            ],
            "temperature": 0.3,
            "max_tokens": 3000
          }
          EOFJ
          
          # Insert prompt content safely using jq
          jq --arg prompt "$FULL_PROMPT" '.messages[1].content = $prompt' request_base.json > request.json
          
          # Call GitHub Models API
          echo "üåê Calling GitHub Models API..."
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Content-Type: application/json" \
            --data @request.json \
            https://models.inference.ai.azure.com/chat/completions)
          
          # Extract HTTP status code and body
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')
          
          echo "üì° HTTP Status: $HTTP_CODE"
          
          # Validate response
          if [ -z "$RESPONSE_BODY" ]; then
            echo "‚ùå Empty response from API"
            echo "HTTP Code: $HTTP_CODE"
            exit 1
          fi
          
          # Check HTTP status
          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "‚ùå API request failed with HTTP $HTTP_CODE"
            echo "Response: $RESPONSE_BODY"
            exit 1
          fi
          
          # Check for API errors
          if echo "$RESPONSE_BODY" | jq -e '.error' > /dev/null 2>&1; then
            ERROR_MSG=$(echo "$RESPONSE_BODY" | jq -r '.error.message // "Unknown error"')
            ERROR_CODE=$(echo "$RESPONSE_BODY" | jq -r '.error.code // "unknown"')
            echo "‚ùå API Error [$ERROR_CODE]: ${ERROR_MSG}"
            echo "Full response: $RESPONSE_BODY"
            exit 1
          fi
          
          # Validate response structure and extract content
          if ! echo "$RESPONSE_BODY" | jq -e '.choices[0].message.content' > /dev/null 2>&1; then
            echo "‚ùå Invalid response structure - missing expected content field"
            echo "Response: $RESPONSE_BODY"
            exit 1
          fi
          
          # Extract updated documentation
          echo "$RESPONSE_BODY" | jq -r '.choices[0].message.content' > updated_docs.md
          
          if [ ! -s updated_docs.md ]; then
            echo "‚ùå Generated documentation is empty"
            exit 1
          fi
          
          echo "‚úÖ Documentation updates generated ($(wc -l < updated_docs.md) lines)"

      - name: Apply documentation updates
        if: steps.analyze-changes.outputs.change_count > 0
        id: apply-updates
        run: |
          echo "‚úçÔ∏è  Applying documentation updates..."
          
          # Backup current docs
          cp docs/README.md docs/README.md.backup 2>/dev/null || true
          
          # Apply updates to main README
          cp updated_docs.md docs/README.md
          
          # Check if anything actually changed
          if git diff --quiet docs/; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No documentation changes needed"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Documentation updated"
            
            # Show what changed
            echo "üìù Documentation diff:"
            git diff docs/
          fi

      - name: Commit and push changes
        if: steps.apply-updates.outputs.has_changes == 'true'
        run: |
          echo "üíæ Committing documentation updates..."
          
          # Stage documentation changes
          git add docs/
          
          # Create commit with detailed message
          cat << EOF > commit_message.txt
          docs: Auto-update from code changes [skip ci]

          Updated documentation to reflect code changes in commit ${{ github.sha }}

          Changed files:
          $(cat code_changes.txt | sed 's/^/- /')

          Changes: +${{ steps.analyze-changes.outputs.additions }} -${{ steps.analyze-changes.outputs.deletions }}

          Generated by: Demo 4 - Documentation Auto-Updater
          Triggered by: ${{ github.event.head_commit.author.name }}
          Original commit: ${{ github.event.head_commit.message }}
          EOF
          
          git commit -F commit_message.txt
          
          # Push changes with retry logic (handles race conditions)
          echo "üì§ Pushing changes..."
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if git push origin ${{ github.ref_name }}; then
              echo "‚úÖ Documentation updates pushed successfully"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "‚ö†Ô∏è  Push failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
                sleep 2
                # Pull and rebase before retry
                git pull --rebase origin ${{ github.ref_name }} || true
              else
                echo "‚ùå Push failed after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Create summary comment
        if: steps.apply-updates.outputs.has_changes == 'true'
        run: |
          echo "üìä Creating summary..."
          
          # Find related issues/PRs (simple heuristic)
          COMMIT_MSG="${{ github.event.head_commit.message }}"
          if echo "$COMMIT_MSG" | grep -qoE '#[0-9]+'; then
            ISSUE_NUMBER=$(echo "$COMMIT_MSG" | grep -oE '#[0-9]+' | head -1 | tr -d '#')
            echo "Related to issue/PR #${ISSUE_NUMBER}"
          fi

      - name: Upload artifacts
        if: steps.analyze-changes.outputs.change_count > 0
        uses: actions/upload-artifact@v4
        with:
          name: documentation-updates-${{ github.run_number }}
          path: |
            updated_docs.md
            code_changes.diff
            current_docs.txt
            docs/README.md.backup
          retention-days: 30

      - name: Summary
        if: steps.analyze-changes.outputs.change_count > 0
        run: |
          echo "### üìö Documentation Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Changed Files**: ${{ steps.analyze-changes.outputs.change_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Code Changes**: +${{ steps.analyze-changes.outputs.additions }} -${{ steps.analyze-changes.outputs.deletions }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Documentation Files**: ${{ steps.find-docs.outputs.doc_count }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.apply-updates.outputs.has_changes }}" == "true" ]; then
            echo "- **Status**: ‚úÖ Documentation updated and committed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üìù Documentation Changes" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```diff' >> $GITHUB_STEP_SUMMARY
            git diff HEAD^ docs/README.md | head -50 >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Status**: ‚ÑπÔ∏è  No documentation updates needed" >> $GITHUB_STEP_SUMMARY
          fi
